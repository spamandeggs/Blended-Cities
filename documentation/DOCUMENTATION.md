IMPORTANT INFOS ABOUT INTERNAL
ALL OF THIS IS WIP AND OPEN TO DISCUSSION / COMMIT

TO USE IT
---------
 - the script does not erase its data between two execution : if you disable / enable it, datas will still be here
    or if you save the file, restart blender and execute the script, datas will be retrieved.
 - to erase the datas, retrieve the starting default state, hit the initialise button. or, in the console :
        city = bpy.context.scene.city
        city.init()
 - user intefaces are located on the left of the 3d view, in the tool shelf, under Object Tools.
    a 'Blended Cities' panel should be there.
 - when you select an object, an 'Outlines' panel shows up. it permits to define an object as a city element outline.
    the object shape must be like one or several perimeter for now. the script will fail if you try to add other kind of objects.
    example of elligible objects for now :
![](images/otl0.png)
![](images/otl1.png)
![](images/otl2.png)
 - in the dropdown menu of the 'Outlines' panel, select one of the 'builder'. the builder is the code that will be
    generated to spawn an object from the outline. each builder will spawn a different kind of object. in this example,
    the builder selected will be 'buildings'.
 - once the 'buildings' builder selected, confirm the selection with the button on the right of the dropdown menu.
 - right after this, an object appears from the outline object, and a configuration panel with the name of the builder appears too.
    ( 'buildings' in that case )
 - the generated object is completely configured from the 'buildings' menu, that display the properties of the object, and from the outline
    that defines its shape.
    so far, you can :
     - use the 'Unit Scale' slider in the Blended Cities oanel to adjust the scale.
     - move/scale/rotate the outline object and refresh a bit the properties of the building to see the changes
     - edit the outlines (add/move/delete vertices, provided it remains a closed shape) and refreh a bit the properties.
     - add a new part above the building with the 'add a part above this' button : select the building or the outline and hit this.
        a new building part appears above the first one. you can edit its outline shape.
        if you change a property of the parent building part, like change the floors number, the child building part will update.
        you can add as many parts as you want to define a building entity.
     - navigate between the different part of the building entity with the arrows
     - autorefresh the selected object : clic the start button in the blended cities menu.
     - duplicate the Outline object that was used to generate the first part and generate a new building from it.
     - rename the objects as you want.
     - erase all the generated objects and rebuild all of them from the 'Rebuild All' button in the blended cities panel.

there's other things you can do through the console, working examples are available in documentation/internal/examples
all the properties of a building or of another object generated by a builder can be changed from the console or another script.
supposing you build a building from an outline named Plane, you can type :

    city = bpy.context.scene.city
    # this retrieve the building element and the outline element of the generated object buildings.00000
    blg, otl = city.elementGet('buildings.00000')
    # this change the number of floors
    blg.floorNumber = 25
    # supposing there is another outline object named Plane.001 :
    otl.objectAttach('Plane.001')

I agree the generated shapes are ugly fot the moment :) it's still about concept for now, more than geometry
to be continued.

CODE
----
 - should conform to the PEP8 guidelines (so no TAB but spaces for indent)
        http://www.python.org/dev/peps/pep-0008/
        http://pych.atomidata.com/code#code-line-1    Online PEP 8 Python code checker
        http://media.jehaisleprintemps.net/talks/pep8-talk/#slide1 funny and educative page about this but in french

    ** contradiction with the conventions for function names below. I think..


VOCABULARY SO FAR
-----------------

 - collections :

        first letter is upper-case, always plural : we talk about collections of elements like the Elements collection
            Elements
            Outlines
            Builders.Buildings
         -.


 - city methods and functions :

        are namedLikeThis(), whereas blender functions are named_like_this().
        function prefix is the python object related to it, function suffix is the action. like :
            city.elementAdd()
            city.elementRemove()
            elm.childList()
            otl.selectParent()


 - classes declarations

        should begin with BC_
        operators with BC_OP (need to be modified since for now its OP_BC_)
        panels with BC_PN

        NOTES : to discuss : there's some normalisation to apply when registering class into bpy. but I don't know it quiet well


 - 3D objects

        **object**    means a 3d object. (object real names are free.)


 - elements in city classes

        an **element** is a row defining an element of the city in one of the collections. this could be a
        Builders.Buildings element, or a Outlines element, an Elements element.. often (should be always)
        designated by **elm** in the code.

        an **outline** is an element from the Outlines collection. designated by **otl** in the code.

        a **builder** is an element from one of the Builders sub-collections.  designated by **bld** in the code.
        one can found blg too since buildings were the first builder to show up but should be edited.

        other will be found in code for well known builders class, like blg or sdw

        **bld_xxx**    smtg related to a builder like :

            bld_parent    the parent element part
            bld_child    a child element part
            blg_main    the root element
            blg_otl        the outline attached to a building

        element names for now are like :
            <elementcollectionnameclass>.01207
            outlines.00000
            buildings.00000 (we know it's the Builders.Buildings element from the name)

        childs elements of an element like building.00024 are named :
            building.00024.00010

            there's only one level in the name. it does not reflect the hierarchy

            building.00024---o---building.00024.00000   o---building.00024.00002
                             |                          |
                             o---building.00024.00001---o---building.00024.00003---building.00024.00004

        ** the name must not be changed ** (unless you use a city.method for a special thing to do)

         - it's used for internal lookup
         - it acts as a database key for collection relation ship, element parenting

        NOTES :
         - I'm not sure it's really helpful to add a suffix for childs elements building.00024.00000. all
            the parenting informations can be retrieved from Outlines
         - the type field becomes useless now in the Elements class. and I don't like the name too


ELEMENTS ORGANISATION
---------------------

    an object is partly defined by its attached outline object. for each object there's an outline object.
    they corresponds to one outline element and one builder element.

    each element name must always be in two collections :
     - either in the Outlines collection or one of the Builders sub-collection (Buildings etc)
     - and the Elements collection, whatever it's an outline or a builder

    so for one city mesh object like a building part, there's :
     - blg.name in the Elements collection,
     - blg.name in the Builders.Buildings collection,
     - the attached outline as a 3d object,
     - otl.name in the Elements collection,
     - otl.name in the Outlines collection

    ** city.elementAdd() cares about all of this. you must not add a member directly in one of the collection
    since they need to stay in sync !

    elements main operation like add, remove etc.. must be done from/should resides among the city methods.


ELEMENT CLASSES INHERITANCE
---------------------------
    Elements
        Outlines
        Builders
            Buildings
                Residentials (would be a subclass of Buildings that define more properties for Buildings, or mod existing as you said)
                Roofs
                Skycrapers
             -..
            Roads
            Sidewalks.


BPY ACCESS AND METHODS
----------------------

    the last info about internal are documented here :
        read only    http://jerome.le.chat.free.fr/projets/blendedCities25/documentation/internal/html/index.html
        git            https://github.com/littleneo/Blended-Cities/tree/master/documentation/internal

    example of commands will be in the example folder :
        read only    http://jerome.le.chat.free.fr/projets/blendedCities25/documentation/internal/examples/
        git            https://github.com/littleneo/Blended-Cities/tree/master/documentation/internal/examples



    city = bpy.context.scene.city
    cityops = bpy.ops.......

    name                        description

    city                         main city.methods() main variables
    city.elements                collection and elm.methods()
        name                    
        pointer                        the memory pointer to the object

    city.outlines                collections and otl.methods()
        name
        attached                    the name of the attached builder
        data
        parent                        the parent outline
        childs                        the childs

    city.builders                bld.methods() none yet
        name
        attached                    the name of the attached peer
        build properties

    city.builders.buildings        a collection and blg.methods()
    city.builders.sidewalks        another coeection with its own methods related to each of its member in the collection

    ** some of the methods related to Outlines methods are declared in Elements, like relationship or select :
        so one can write, from any kind of element :    elm.childList()
        rather than :                                    elm.asOutline().childList()

    there's not a unique collection for elements since the builders will have different properties, and a different number of it.
    outline and builders are apart since an outline builds nothing by itself, and that the builder should'nt have to care about
    relative selection stuff (select parent, child, sibling..). also : the outline is in some case defined by the object,
    whereas the builder element is never defined by its object.

    Elements is used for lookup things ( index() object()..) thanks to its pointer field.


MODULES, NAMESPACES, AND FILES
------------------------------

    the builders class reside in /builders
    builders collection and panel classes have been splitted into two parts :
        idea was to use the
    TBD

CITY MAIN SCALE
---------------

    the script use the METRIC system, the generated objects will be deformed by the scene scale specified for the scene.
    useful to change the scale of a set of imported outlines.
    by default its 1 blender unit = 1 meter, scale 1.0

    the outlines themselves are not influenced by the scene scale : their relative scale to each other can be changed using alt-S.
    only the attached/generated objects are.
    so when reading an outline geometry, the real coordinates in blender units, retrieved from the outline data field or straight
    from the object, it must be converted into meters before. every build() method of every Builders must not handle that else it won't
    be scaled properly. build() will work on metric coordinates, not directly on BU coordinates.

    so there's a layer between coord in BU and coord in meters, between the outline and its object :

     - when build() need to read the outline data, he calls otl.dataGet() it does not parse the outline mesh by itself
     - dataGet() returns the info as meters
     - if the outline mesh needs to be read again it call dataRead() before :
                otl.dataRead() # then
                otl.dataGet()
     - when build() gives the result of its operation to objectBuild() coordinates are still in meters. objectBuild() will care about
          meters to BU conversion.

GEOMETRY
--------

    extracted verts/coordinates should always be as Vector, not list :
        >>> vert = [1,2,3]
        >>> vert * 2
        [1, 2, 3, 1, 2, 3]

        >>> vert = Vector([1,2,3])
        >>> vert * 2
        Vector((2.0, 4.0, 6.0))
